syntax = "proto3";
// package name placeholder
package com.ecoflow;
/* 公共message-主要是提供一些公共类型，会在通信\功能message被嵌入调用*/
/*********************************Public_Message-Start*********************************/

/**
* @message 公共通信消息
* @type public
* @brief 所有发送的数据包，外部通信包
* @pdata ：自己项目protobuf序列化后的真实数据
* @optional的其他成员 ：根据自己项目填充通讯所需的cmd_func、cmd_id等等，如果需要，秩序继续向后扩充，不会影响其他项目编译
* @使用流程：
*  1.向pdata填充真实数据
*  2.根据项目需求填写外部标志位用于识别pdata的真实熟悉
*/
message Header{
  bytes           pdata       = 1;    ///<参数数据。不限长度。必填
  int32           src         = 2;    ///< SRC   包的源地址
  int32           dest        = 3;    ///< DST  包的目的地址
  int32           d_src       = 4;    ///< D-SRC 动态-包的源地址， v2传0
  int32           d_dest      = 5;    ///< D-DST 动态-包的目的地址， v2传0
  int32           enc_type    = 6;    ///<CTRL字段的，bit:5-6,chk_type字段， 0-不加密 1-加密
  int32           check_type  = 7;    ///<CTRL字段的，bit:2-4,chk_type字段
  int32           cmd_func    = 8;    ///<CMD_SET 指令集ID
  int32           cmd_id      = 9;    ///<CMD_ID 子命令ID    指令集下的某一个指令。cmd_func + cmd_id 可唯一确认一个message，指示当前消息头对应的pdata对应解析哪个Message
  int32           data_len    = 10;   ///<LEN：数据包长度
  int32           need_ack    = 11;   ///<CTRL字段的，bit0,need_ack字段， 0-不需要回ack， 1-回ack
  int32           is_ack      = 12;   ///<CTRL字段的，bit:1,is_type字段, 0-请求， 1-应答
  int32           seq         = 14;   ///<SEQ,包序号。序列号，有发送方决定，ACK包原样返回;
  int32           product_id  = 15;   ///<PRODUCT_INFO,设备信息
  int32           version     = 16;   ///< VER协议版本，通信协议版本。默认值是3， v2填2，v3填3
  int32           payload_ver = 17;   //区分payload类型，0-原始数据， 1-protobuf
  optional int32  time_snap   = 18;   ///<V2、V3未使用，
  optional int32  is_rw_cmd   = 19;   ///<V2、V3未使用，
  optional int32  is_queue    = 20;   ///<V2、V3未使用，
  optional int32  ack_type    = 21;   ///<V2、V3未使用，
  optional string code        = 22;   ///<状态码，用于后台和app的业务交互状态码
  optional  string from        = 23;   ///<来源 用于区分app消息来源，ios/android
  optional string module_sn   = 24;   ///模块sn
}
/**********************************Public_Message-End**********************************/



/**
* @message 发送消息包
* @type public
* @brief 发送消息的集合包
* @pdata ：多包发送消息，每一包均可不一样，降低网络通信频率
* @optional
*  1.每一个msg可以是独立类型
*  2.数据包的数量只有到options文件的限制、以及MQTT单次发送数据量上限限制
*/
message Send_Header_Msg{
  repeated Header msg = 1;///< 公共通信消息,IOT\服务器每一次推送MQTT服务器可以实现多包缓存后再发送，每一包大小不一致也不影响
}

/**
* @message 公共通信消息头部（大内存平台可以不使用）
* @type public
* @brief 用于部分平台实现数据传递方法，利用头部传递，降低内存占用
* @
* @使用流程：
*  1.申请"SendMsgHart"变量，赋值后，传递给处理函数（方法）
*  2.处理函数（方法）根据头部的数据是否!=null，判断内部序列化是否话optional has使能
*/
message SendMsgHart{
  int32 link_id    = 1;
  int32 src        = 2;
  int32 dest       = 3;
  int32 d_src      = 4;
  int32 d_dest     = 5;
  int32 enc_type   = 6;
  int32 check_type = 7;
  int32 cmd_func   = 8;
  int32 cmd_id     = 9;
  int32 data_len   = 10;
  int32 need_ack   = 11;
  int32 is_ack     = 12;
  int32 ack_type   = 13;
  int32 seq        = 14;
  int32 time_snap  = 15;
  int32 is_rw_cmd  = 16;
  int32 is_queue   = 17;
  int32 product_id = 18;
  int32 version    = 19;
}
